import { BaseRenderable, Renderable, type RenderableOptions } from "../Renderable";
import { Selection } from "../lib/selection";
import { StyledText } from "../lib/styled-text";
import { type TextChunk } from "../text-buffer";
import { RGBA } from "../lib/RGBA";
import { type RenderContext } from "../types";
import type { OptimizedBuffer } from "../buffer";
import { RootTextNodeRenderable, TextNodeRenderable } from "./TextNode";
export interface TextOptions extends RenderableOptions<TextRenderable> {
    content?: StyledText | string;
    fg?: string | RGBA;
    bg?: string | RGBA;
    selectionBg?: string | RGBA;
    selectionFg?: string | RGBA;
    selectable?: boolean;
    attributes?: number;
    wrap?: boolean;
    wrapMode?: "char" | "word";
}
export declare class TextRenderable extends Renderable {
    selectable: boolean;
    private _text;
    private _hasManualStyledText;
    private _defaultFg;
    private _defaultBg;
    private _defaultAttributes;
    private _selectionBg;
    private _selectionFg;
    private _wrap;
    private _wrapMode;
    private lastLocalSelection;
    private textBuffer;
    private _lineInfo;
    protected rootTextNode: RootTextNodeRenderable;
    protected _defaultOptions: {
        content: string;
        fg: RGBA;
        bg: RGBA;
        selectionBg: undefined;
        selectionFg: undefined;
        selectable: true;
        attributes: number;
        wrap: true;
        wrapMode: "char" | "word";
    };
    constructor(ctx: RenderContext, options: TextOptions);
    private updateTextBuffer;
    private clearChunks;
    get content(): StyledText;
    get plainText(): string;
    get textLength(): number;
    get chunks(): TextChunk[];
    get textNode(): RootTextNodeRenderable;
    set content(value: StyledText | string);
    get fg(): RGBA;
    set fg(value: RGBA | string | undefined);
    get selectionBg(): RGBA | undefined;
    set selectionBg(value: RGBA | string | undefined);
    get selectionFg(): RGBA | undefined;
    set selectionFg(value: RGBA | string | undefined);
    get bg(): RGBA;
    set bg(value: RGBA | string | undefined);
    get attributes(): number;
    set attributes(value: number);
    get wrap(): boolean;
    set wrap(value: boolean);
    get wrapMode(): "char" | "word";
    set wrapMode(value: "char" | "word");
    protected onResize(width: number, height: number): void;
    private updateLocalSelection;
    private updateTextInfo;
    private updateLineInfo;
    private updateWrapWidth;
    private setupMeasureFunc;
    insertChunk(chunk: TextChunk, index?: number): void;
    removeChunk(chunk: TextChunk): void;
    replaceChunk(chunk: TextChunk, oldChunk: TextChunk): void;
    private updateTextFromNodes;
    add(obj: TextNodeRenderable | StyledText | string, index?: number): number;
    remove(id: string): void;
    insertBefore(obj: BaseRenderable | any, anchor?: TextNodeRenderable): number;
    getTextChildren(): BaseRenderable[];
    clear(): void;
    shouldStartSelection(x: number, y: number): boolean;
    onSelectionChanged(selection: Selection | null): boolean;
    getSelectedText(): string;
    hasSelection(): boolean;
    getSelection(): {
        start: number;
        end: number;
    } | null;
    onLifecyclePass: () => void;
    render(buffer: OptimizedBuffer, deltaTime: number): void;
    protected renderSelf(buffer: OptimizedBuffer): void;
    destroy(): void;
}
