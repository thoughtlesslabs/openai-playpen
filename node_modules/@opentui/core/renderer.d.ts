import { Renderable, RootRenderable } from "./Renderable";
import { type CursorStyle, DebugOverlayCorner, type RenderContext, type WidthMethod } from "./types";
import { RGBA, type ColorInput } from "./lib/RGBA";
import type { Pointer } from "bun:ffi";
import { OptimizedBuffer } from "./buffer";
import { type RenderLib } from "./zig";
import { TerminalConsole, type ConsoleOptions } from "./console";
import { type MouseEventType, type RawMouseEvent, type ScrollInfo } from "./lib/parse.mouse";
import { Selection } from "./lib/selection";
import { EventEmitter } from "events";
import { KeyHandler } from "./lib/KeyHandler";
export interface CliRendererConfig {
    stdin?: NodeJS.ReadStream;
    stdout?: NodeJS.WriteStream;
    exitOnCtrlC?: boolean;
    debounceDelay?: number;
    targetFps?: number;
    memorySnapshotInterval?: number;
    useThread?: boolean;
    gatherStats?: boolean;
    maxStatSamples?: number;
    consoleOptions?: ConsoleOptions;
    postProcessFns?: ((buffer: OptimizedBuffer, deltaTime: number) => void)[];
    enableMouseMovement?: boolean;
    useMouse?: boolean;
    useAlternateScreen?: boolean;
    useConsole?: boolean;
    experimental_splitHeight?: number;
    useKittyKeyboard?: boolean;
}
export type PixelResolution = {
    width: number;
    height: number;
};
export declare class MouseEvent {
    readonly type: MouseEventType;
    readonly button: number;
    readonly x: number;
    readonly y: number;
    readonly source?: Renderable;
    readonly modifiers: {
        shift: boolean;
        alt: boolean;
        ctrl: boolean;
    };
    readonly scroll?: ScrollInfo;
    readonly target: Renderable | null;
    readonly isSelecting?: boolean;
    private _propagationStopped;
    private _defaultPrevented;
    get propagationStopped(): boolean;
    get defaultPrevented(): boolean;
    constructor(target: Renderable | null, attributes: RawMouseEvent & {
        source?: Renderable;
        isSelecting?: boolean;
    });
    stopPropagation(): void;
    preventDefault(): void;
}
export declare enum MouseButton {
    LEFT = 0,
    MIDDLE = 1,
    RIGHT = 2,
    WHEEL_UP = 4,
    WHEEL_DOWN = 5
}
export declare function createCliRenderer(config?: CliRendererConfig): Promise<CliRenderer>;
export declare enum CliRenderEvents {
    DEBUG_OVERLAY_TOGGLE = "debugOverlay:toggle"
}
export declare class CliRenderer extends EventEmitter implements RenderContext {
    private static animationFrameId;
    private lib;
    rendererPtr: Pointer;
    stdin: NodeJS.ReadStream;
    private stdout;
    private exitOnCtrlC;
    private isDestroyed;
    nextRenderBuffer: OptimizedBuffer;
    currentRenderBuffer: OptimizedBuffer;
    private _isRunning;
    private targetFps;
    private automaticMemorySnapshot;
    private memorySnapshotInterval;
    private memorySnapshotTimer;
    private lastMemorySnapshot;
    readonly root: RootRenderable;
    width: number;
    height: number;
    private _useThread;
    private gatherStats;
    private frameTimes;
    private maxStatSamples;
    private postProcessFns;
    private backgroundColor;
    private waitingForPixelResolution;
    private rendering;
    private renderingNative;
    private renderTimeout;
    private lastTime;
    private frameCount;
    private lastFpsTime;
    private currentFps;
    private targetFrameTime;
    private immediateRerenderRequested;
    private updateScheduled;
    private liveRequestCounter;
    private controlState;
    private frameCallbacks;
    private renderStats;
    debugOverlay: {
        enabled: boolean;
        corner: DebugOverlayCorner;
    };
    private _console;
    private _resolution;
    private _keyHandler;
    private animationRequest;
    private resizeTimeoutId;
    private resizeDebounceDelay;
    private enableMouseMovement;
    private _useMouse;
    private _useAlternateScreen;
    private capturedRenderable?;
    private lastOverRenderableNum;
    private lastOverRenderable?;
    private currentSelection;
    private selectionContainers;
    private _splitHeight;
    private renderOffset;
    private _terminalWidth;
    private _terminalHeight;
    private _terminalIsSetup;
    private realStdoutWrite;
    private captureCallback;
    private _useConsole;
    private mouseParser;
    private sigwinchHandler;
    private _capabilities;
    private _latestPointer;
    private _currentFocusedRenderable;
    private lifecyclePasses;
    private handleError;
    private dumpOutputCache;
    private exitHandler;
    private warningHandler;
    constructor(lib: RenderLib, rendererPtr: Pointer, stdin: NodeJS.ReadStream, stdout: NodeJS.WriteStream, width: number, height: number, config?: CliRendererConfig);
    registerLifecyclePass(renderable: Renderable): void;
    unregisterLifecyclePass(renderable: Renderable): void;
    getLifecyclePasses(): Set<Renderable>;
    get currentFocusedRenderable(): Renderable | null;
    focusRenderable(renderable: Renderable): void;
    addToHitGrid(x: number, y: number, width: number, height: number, id: number): void;
    get widthMethod(): WidthMethod;
    private writeOut;
    requestRender(): void;
    get useConsole(): boolean;
    set useConsole(value: boolean);
    get isRunning(): boolean;
    get resolution(): PixelResolution | null;
    get console(): TerminalConsole;
    get keyInput(): KeyHandler;
    get terminalWidth(): number;
    get terminalHeight(): number;
    get useThread(): boolean;
    get useMouse(): boolean;
    set useMouse(useMouse: boolean);
    get experimental_splitHeight(): number;
    get liveRequestCount(): number;
    get currentControlState(): string;
    get capabilities(): any | null;
    set experimental_splitHeight(splitHeight: number);
    private interceptStdoutWrite;
    disableStdoutInterception(): void;
    private flushStdoutCache;
    private enableMouse;
    private disableMouse;
    enableKittyKeyboard(flags?: number): void;
    disableKittyKeyboard(): void;
    set useThread(useThread: boolean);
    setupTerminal(): Promise<void>;
    private stdinListener;
    private setupInput;
    private handleMouseData;
    private takeMemorySnapshot;
    private startMemorySnapshotTimer;
    private stopMemorySnapshotTimer;
    setMemorySnapshotInterval(interval: number): void;
    private handleResize;
    private queryPixelResolution;
    private processResize;
    setBackgroundColor(color: ColorInput): void;
    toggleDebugOverlay(): void;
    configureDebugOverlay(options: {
        enabled?: boolean;
        corner?: DebugOverlayCorner;
    }): void;
    setTerminalTitle(title: string): void;
    dumpHitGrid(): void;
    dumpBuffers(timestamp?: number): void;
    dumpStdoutBuffer(timestamp?: number): void;
    static setCursorPosition(renderer: CliRenderer, x: number, y: number, visible?: boolean): void;
    static setCursorStyle(renderer: CliRenderer, style: CursorStyle, blinking?: boolean, color?: RGBA): void;
    static setCursorColor(renderer: CliRenderer, color: RGBA): void;
    setCursorPosition(x: number, y: number, visible?: boolean): void;
    setCursorStyle(style: CursorStyle, blinking?: boolean, color?: RGBA): void;
    setCursorColor(color: RGBA): void;
    addPostProcessFn(processFn: (buffer: OptimizedBuffer, deltaTime: number) => void): void;
    removePostProcessFn(processFn: (buffer: OptimizedBuffer, deltaTime: number) => void): void;
    clearPostProcessFns(): void;
    setFrameCallback(callback: (deltaTime: number) => Promise<void>): void;
    removeFrameCallback(callback: (deltaTime: number) => Promise<void>): void;
    clearFrameCallbacks(): void;
    requestLive(): void;
    dropLive(): void;
    start(): void;
    auto(): void;
    private internalStart;
    pause(): void;
    private internalPause;
    stop(): void;
    private internalStop;
    destroy(): void;
    private startRenderLoop;
    private loop;
    intermediateRender(): void;
    private renderNative;
    private collectStatSample;
    getStats(): {
        fps: number;
        frameCount: number;
        frameTimes: number[];
        averageFrameTime: number;
        minFrameTime: number;
        maxFrameTime: number;
    };
    resetStats(): void;
    setGatherStats(enabled: boolean): void;
    getSelection(): Selection | null;
    get hasSelection(): boolean;
    getSelectionContainer(): Renderable | null;
    clearSelection(): void;
    private startSelection;
    private updateSelection;
    requestSelectionUpdate(): void;
    private isWithinContainer;
    private finishSelection;
    private notifySelectablesOfSelectionChange;
    private walkSelectableRenderables;
}
