{
  "version": 3,
  "sources": ["../src/testing/mock-keys.ts", "../src/testing/mock-mouse.ts", "../src/testing/test-renderer.ts"],
  "sourcesContent": [
    "import type { CliRenderer } from \"../renderer\"\nimport { ANSI } from \"../ansi\"\n\nexport const KeyCodes = {\n  // Control keys\n  ENTER: \"\\r\",\n  TAB: \"\\t\",\n  BACKSPACE: \"\\b\",\n  // NOTE: This may depend on the platform and terminals\n  DELETE: \"\\x1b[3~\",\n  HOME: \"\\x1b[H\",\n  END: \"\\x1b[F\",\n  ESCAPE: \"\\x1b\",\n\n  // Arrow keys\n  ARROW_UP: \"\\x1b[A\",\n  ARROW_DOWN: \"\\x1b[B\",\n  ARROW_RIGHT: \"\\x1b[C\",\n  ARROW_LEFT: \"\\x1b[D\",\n\n  // Function keys\n  F1: \"\\x1bOP\",\n  F2: \"\\x1bOQ\",\n  F3: \"\\x1bOR\",\n  F4: \"\\x1bOS\",\n  F5: \"\\x1b[15~\",\n  F6: \"\\x1b[17~\",\n  F7: \"\\x1b[18~\",\n  F8: \"\\x1b[19~\",\n  F9: \"\\x1b[20~\",\n  F10: \"\\x1b[21~\",\n  F11: \"\\x1b[23~\",\n  F12: \"\\x1b[24~\",\n\n  // Control combinations\n  CTRL_A: \"\\x01\",\n  CTRL_B: \"\\x02\",\n  CTRL_C: \"\\x03\",\n  CTRL_D: \"\\x04\",\n  CTRL_E: \"\\x05\",\n  CTRL_F: \"\\x06\",\n  CTRL_G: \"\\x07\",\n  CTRL_H: \"\\x08\",\n  CTRL_I: \"\\t\",\n  CTRL_J: \"\\n\",\n  CTRL_K: \"\\x0b\",\n  CTRL_L: \"\\x0c\",\n  CTRL_M: \"\\r\",\n  CTRL_N: \"\\x0e\",\n  CTRL_O: \"\\x0f\",\n  CTRL_P: \"\\x10\",\n  CTRL_Q: \"\\x11\",\n  CTRL_R: \"\\x12\",\n  CTRL_S: \"\\x13\",\n  CTRL_T: \"\\x14\",\n  CTRL_U: \"\\x15\",\n  CTRL_V: \"\\x16\",\n  CTRL_W: \"\\x17\",\n  CTRL_X: \"\\x18\",\n  CTRL_Y: \"\\x19\",\n  CTRL_Z: \"\\x1a\",\n\n  // Alt combinations\n  ALT_A: \"\\x1ba\",\n  ALT_B: \"\\x1bb\",\n  ALT_C: \"\\x1bc\",\n  // ... add more as needed\n} as const\n\nexport type KeyInput = string | keyof typeof KeyCodes\n\nexport function createMockKeys(renderer: CliRenderer) {\n  const pressKeys = async (keys: KeyInput[], delayMs: number = 0): Promise<void> => {\n    for (const key of keys) {\n      let keyCode: string\n      if (typeof key === \"string\") {\n        // If it's a string but also exists in KeyCodes, use the KeyCodes value\n        if (key in KeyCodes) {\n          keyCode = KeyCodes[key as keyof typeof KeyCodes]\n        } else {\n          keyCode = key\n        }\n      } else {\n        // It's a KeyCode enum value\n        keyCode = KeyCodes[key]\n        if (!keyCode) {\n          throw new Error(`Unknown key: ${key}`)\n        }\n      }\n\n      renderer.stdin.emit(\"data\", Buffer.from(keyCode))\n\n      if (delayMs > 0) {\n        await new Promise((resolve) => setTimeout(resolve, delayMs))\n      }\n    }\n  }\n\n  const pressKey = (key: KeyInput): void => {\n    let keyCode: string\n    if (typeof key === \"string\") {\n      // If it's a string but also exists in KeyCodes, use the KeyCodes value\n      if (key in KeyCodes) {\n        keyCode = KeyCodes[key as keyof typeof KeyCodes]\n      } else {\n        keyCode = key\n      }\n    } else {\n      // This branch handles KeyCode enum values (though they're strings at runtime)\n      keyCode = KeyCodes[key]\n      if (!keyCode) {\n        throw new Error(`Unknown key: ${key}`)\n      }\n    }\n\n    renderer.stdin.emit(\"data\", Buffer.from(keyCode))\n  }\n\n  const typeText = async (text: string, delayMs: number = 0): Promise<void> => {\n    const keys = text.split(\"\")\n    await pressKeys(keys, delayMs)\n  }\n\n  const pressEnter = (): void => {\n    pressKey(KeyCodes.ENTER)\n  }\n\n  const pressEscape = (): void => {\n    pressKey(KeyCodes.ESCAPE)\n  }\n\n  const pressTab = (): void => {\n    pressKey(KeyCodes.TAB)\n  }\n\n  const pressBackspace = (): void => {\n    pressKey(KeyCodes.BACKSPACE)\n  }\n\n  const pressArrow = (direction: \"up\" | \"down\" | \"left\" | \"right\"): void => {\n    const keyMap = {\n      up: KeyCodes.ARROW_UP,\n      down: KeyCodes.ARROW_DOWN,\n      left: KeyCodes.ARROW_LEFT,\n      right: KeyCodes.ARROW_RIGHT,\n    }\n    pressKey(keyMap[direction])\n  }\n\n  const pressCtrlC = (): void => {\n    pressKey(KeyCodes.CTRL_C)\n  }\n\n  const pasteBracketedText = (text: string): Promise<void> => {\n    return pressKeys([ANSI.bracketedPasteStart, text, ANSI.bracketedPasteEnd])\n  }\n\n  return {\n    pressKeys,\n    pressKey,\n    typeText,\n    pressEnter,\n    pressEscape,\n    pressTab,\n    pressBackspace,\n    pressArrow,\n    pressCtrlC,\n    pasteBracketedText,\n  }\n}\n",
    "import type { CliRenderer } from \"../renderer\"\n\nexport const MouseButtons = {\n  LEFT: 0,\n  MIDDLE: 1,\n  RIGHT: 2,\n\n  WHEEL_UP: 64, // 64 = scroll flag + 0\n  WHEEL_DOWN: 65, // 64 + 1\n  WHEEL_LEFT: 66, // 64 + 2\n  WHEEL_RIGHT: 67, // 64 + 3\n} as const\n\nexport type MouseButton = (typeof MouseButtons)[keyof typeof MouseButtons]\n\nexport interface MousePosition {\n  x: number\n  y: number\n}\n\nexport interface MouseModifiers {\n  shift?: boolean\n  alt?: boolean\n  ctrl?: boolean\n}\n\nexport type MouseEventType = \"down\" | \"up\" | \"move\" | \"drag\" | \"scroll\"\n\nexport interface MouseEventOptions {\n  button?: MouseButton\n  modifiers?: MouseModifiers\n  delayMs?: number\n}\n\nexport function createMockMouse(renderer: CliRenderer) {\n  let currentPosition: MousePosition = { x: 0, y: 0 }\n  let buttonsPressed = new Set<MouseButton>()\n\n  // Generate SGR mouse event sequence\n  const generateMouseEvent = (\n    type: MouseEventType,\n    x: number,\n    y: number,\n    button: MouseButton = MouseButtons.LEFT,\n    modifiers: MouseModifiers = {},\n  ): string => {\n    // SGR format: \\x1b[<b;x;yM or \\x1b[<b;x;ym\n    // where b = button code + modifier flags + motion/scroll flags\n\n    let buttonCode: number = button\n\n    // Add modifier flags\n    if (modifiers.shift) buttonCode |= 4\n    if (modifiers.alt) buttonCode |= 8\n    if (modifiers.ctrl) buttonCode |= 16\n\n    switch (type) {\n      case \"move\":\n        buttonCode = 32 | 3 // motion flag (32) + button 3 for motion without button press\n        if (modifiers.shift) buttonCode |= 4\n        if (modifiers.alt) buttonCode |= 8\n        if (modifiers.ctrl) buttonCode |= 16\n        break\n      case \"drag\":\n        buttonCode = (buttonsPressed.size > 0 ? Array.from(buttonsPressed)[0] : button) | 32\n        if (modifiers.shift) buttonCode |= 4\n        if (modifiers.alt) buttonCode |= 8\n        if (modifiers.ctrl) buttonCode |= 16\n        break\n      case \"scroll\":\n        // Scroll events already have the scroll flag set in the button code\n        break\n    }\n\n    // Convert to 1-based coordinates for ANSI\n    const ansiX = x + 1\n    const ansiY = y + 1\n\n    let pressRelease = \"M\" // Default to press\n    if (type === \"up\" || type === \"move\" || type === \"drag\") {\n      pressRelease = \"m\"\n    }\n\n    return `\\x1b[<${buttonCode};${ansiX};${ansiY}${pressRelease}`\n  }\n\n  const emitMouseEvent = async (\n    type: MouseEventType,\n    x: number,\n    y: number,\n    button: MouseButton = MouseButtons.LEFT,\n    options: Omit<MouseEventOptions, \"button\"> = {},\n  ): Promise<void> => {\n    const { modifiers = {}, delayMs = 0 } = options\n\n    const eventSequence = generateMouseEvent(type, x, y, button, modifiers)\n    renderer.stdin.emit(\"data\", Buffer.from(eventSequence))\n\n    currentPosition = { x, y }\n\n    if (type === \"down\" && button < 64) {\n      buttonsPressed.add(button)\n    } else if (type === \"up\") {\n      buttonsPressed.delete(button)\n    }\n\n    if (delayMs > 0) {\n      await new Promise((resolve) => setTimeout(resolve, delayMs))\n    }\n  }\n\n  const moveTo = async (x: number, y: number, options: MouseEventOptions = {}): Promise<void> => {\n    const { button = MouseButtons.LEFT, delayMs = 0, modifiers = {} } = options\n\n    if (buttonsPressed.size > 0) {\n      await emitMouseEvent(\"drag\", x, y, Array.from(buttonsPressed)[0], { modifiers, delayMs })\n    } else {\n      await emitMouseEvent(\"move\", x, y, button, { modifiers, delayMs })\n    }\n\n    currentPosition = { x, y }\n  }\n\n  const click = async (\n    x: number,\n    y: number,\n    button: MouseButton = MouseButtons.LEFT,\n    options: MouseEventOptions = {},\n  ): Promise<void> => {\n    const { delayMs = 10, modifiers = {} } = options\n\n    await emitMouseEvent(\"down\", x, y, button, { modifiers, delayMs })\n    await new Promise((resolve) => setTimeout(resolve, delayMs))\n    await emitMouseEvent(\"up\", x, y, button, { modifiers, delayMs })\n  }\n\n  const doubleClick = async (\n    x: number,\n    y: number,\n    button: MouseButton = MouseButtons.LEFT,\n    options: MouseEventOptions = {},\n  ): Promise<void> => {\n    const { delayMs = 10, modifiers = {} } = options\n\n    await click(x, y, button, { modifiers, delayMs })\n    await new Promise((resolve) => setTimeout(resolve, delayMs))\n    await click(x, y, button, { modifiers, delayMs })\n  }\n\n  const pressDown = async (\n    x: number,\n    y: number,\n    button: MouseButton = MouseButtons.LEFT,\n    options: MouseEventOptions = {},\n  ): Promise<void> => {\n    const { modifiers = {}, delayMs = 0 } = options\n    await emitMouseEvent(\"down\", x, y, button, { modifiers, delayMs })\n  }\n\n  const release = async (\n    x: number,\n    y: number,\n    button: MouseButton = MouseButtons.LEFT,\n    options: MouseEventOptions = {},\n  ): Promise<void> => {\n    const { modifiers = {}, delayMs = 0 } = options\n    await emitMouseEvent(\"up\", x, y, button, { modifiers, delayMs })\n  }\n\n  const drag = async (\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    button: MouseButton = MouseButtons.LEFT,\n    options: MouseEventOptions = {},\n  ): Promise<void> => {\n    const { delayMs = 10, modifiers = {} } = options\n\n    await pressDown(startX, startY, button, { modifiers })\n\n    const steps = 5\n    const dx = (endX - startX) / steps\n    const dy = (endY - startY) / steps\n\n    for (let i = 1; i <= steps; i++) {\n      const currentX = Math.round(startX + dx * i)\n      const currentY = Math.round(startY + dy * i)\n      await emitMouseEvent(\"drag\", currentX, currentY, button, { modifiers, delayMs })\n    }\n\n    await release(endX, endY, button, { modifiers })\n  }\n\n  const scroll = async (\n    x: number,\n    y: number,\n    direction: \"up\" | \"down\" | \"left\" | \"right\",\n    options: MouseEventOptions = {},\n  ): Promise<void> => {\n    const { modifiers = {}, delayMs = 0 } = options\n\n    let button: MouseButton\n    switch (direction) {\n      case \"up\":\n        button = MouseButtons.WHEEL_UP\n        break\n      case \"down\":\n        button = MouseButtons.WHEEL_DOWN\n        break\n      case \"left\":\n        button = MouseButtons.WHEEL_LEFT\n        break\n      case \"right\":\n        button = MouseButtons.WHEEL_RIGHT\n        break\n    }\n\n    await emitMouseEvent(\"scroll\", x, y, button, { modifiers, delayMs })\n  }\n\n  const getCurrentPosition = (): MousePosition => {\n    return { ...currentPosition }\n  }\n\n  const getPressedButtons = (): MouseButton[] => {\n    return Array.from(buttonsPressed)\n  }\n\n  return {\n    // Core interaction methods\n    moveTo,\n    click,\n    doubleClick,\n    pressDown,\n    release,\n    drag,\n    scroll,\n\n    // State getters\n    getCurrentPosition,\n    getPressedButtons,\n\n    // Low-level event emission (for advanced use cases)\n    emitMouseEvent,\n  }\n}\n",
    "import { CliRenderer, type CliRendererConfig } from \"../renderer\"\nimport { resolveRenderLib } from \"../zig\"\nimport { createMockKeys } from \"./mock-keys\"\nimport { createMockMouse } from \"./mock-mouse\"\n\nexport interface TestRendererOptions extends CliRendererConfig {\n  width?: number\n  height?: number\n}\nexport interface TestRenderer extends CliRenderer {}\nexport type MockInput = ReturnType<typeof createMockKeys>\nexport type MockMouse = ReturnType<typeof createMockMouse>\n\nconst decoder = new TextDecoder()\n\nexport async function createTestRenderer(options: TestRendererOptions): Promise<{\n  renderer: TestRenderer\n  mockInput: MockInput\n  mockMouse: MockMouse\n  renderOnce: () => Promise<void>\n  captureCharFrame: () => string\n  resize: (width: number, height: number) => void\n}> {\n  process.env.OTUI_USE_CONSOLE = \"false\"\n  const renderer = await setupTestRenderer({\n    ...options,\n    useAlternateScreen: false,\n    useConsole: false,\n  })\n\n  renderer.disableStdoutInterception()\n\n  const mockInput = createMockKeys(renderer)\n  const mockMouse = createMockMouse(renderer)\n\n  const renderOnce = async () => {\n    //@ts-expect-error - this is a test renderer\n    await renderer.loop()\n  }\n\n  return {\n    renderer,\n    mockInput,\n    mockMouse,\n    renderOnce,\n    captureCharFrame: () => {\n      const currentBuffer = renderer.currentRenderBuffer\n      const frameBytes = currentBuffer.getRealCharBytes(true)\n      return decoder.decode(frameBytes)\n    },\n    resize: (width: number, height: number) => {\n      //@ts-expect-error - this is a test renderer\n      renderer.processResize(width, height)\n    },\n  }\n}\n\nasync function setupTestRenderer(config: TestRendererOptions) {\n  const stdin = config.stdin || process.stdin\n  const stdout = config.stdout || process.stdout\n\n  const width = config.width || stdout.columns || 80\n  const height = config.height || stdout.rows || 24\n  const renderHeight =\n    config.experimental_splitHeight && config.experimental_splitHeight > 0 ? config.experimental_splitHeight : height\n\n  const ziglib = resolveRenderLib()\n  const rendererPtr = ziglib.createRenderer(width, renderHeight, { testing: true })\n  if (!rendererPtr) {\n    throw new Error(\"Failed to create test renderer\")\n  }\n  if (config.useThread === undefined) {\n    config.useThread = true\n  }\n\n  if (process.platform === \"linux\") {\n    config.useThread = false\n  }\n  ziglib.setUseThread(rendererPtr, config.useThread)\n\n  const renderer = new CliRenderer(ziglib, rendererPtr, stdin, stdout, width, height, config)\n\n  // Do not setup the terminal for testing as we will not actualy output anything to the terminal\n  // await renderer.setupTerminal()\n\n  return renderer\n}\n"
  ],
  "mappings": ";;;;;;;;AAGO,IAAM,WAAW;AAAA,EAEtB,OAAO;AAAA,EACP,KAAK;AAAA,EACL,WAAW;AAAA,EAEX,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,KAAK;AAAA,EACL,QAAQ;AAAA,EAGR,UAAU;AAAA,EACV,YAAY;AAAA,EACZ,aAAa;AAAA,EACb,YAAY;AAAA,EAGZ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,IAAI;AAAA,EACJ,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK;AAAA,EAGL,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EACR,QAAQ;AAAA,EAGR,OAAO;AAAA,EACP,OAAO;AAAA,EACP,OAAO;AAET;AAIO,SAAS,cAAc,CAAC,UAAuB;AAAA,EACpD,MAAM,YAAY,OAAO,MAAkB,UAAkB,MAAqB;AAAA,IAChF,WAAW,OAAO,MAAM;AAAA,MACtB,IAAI;AAAA,MACJ,IAAI,OAAO,QAAQ,UAAU;AAAA,QAE3B,IAAI,OAAO,UAAU;AAAA,UACnB,UAAU,SAAS;AAAA,QACrB,EAAO;AAAA,UACL,UAAU;AAAA;AAAA,MAEd,EAAO;AAAA,QAEL,UAAU,SAAS;AAAA,QACnB,IAAI,CAAC,SAAS;AAAA,UACZ,MAAM,IAAI,MAAM,gBAAgB,KAAK;AAAA,QACvC;AAAA;AAAA,MAGF,SAAS,MAAM,KAAK,QAAQ,OAAO,KAAK,OAAO,CAAC;AAAA,MAEhD,IAAI,UAAU,GAAG;AAAA,QACf,MAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,OAAO,CAAC;AAAA,MAC7D;AAAA,IACF;AAAA;AAAA,EAGF,MAAM,WAAW,CAAC,QAAwB;AAAA,IACxC,IAAI;AAAA,IACJ,IAAI,OAAO,QAAQ,UAAU;AAAA,MAE3B,IAAI,OAAO,UAAU;AAAA,QACnB,UAAU,SAAS;AAAA,MACrB,EAAO;AAAA,QACL,UAAU;AAAA;AAAA,IAEd,EAAO;AAAA,MAEL,UAAU,SAAS;AAAA,MACnB,IAAI,CAAC,SAAS;AAAA,QACZ,MAAM,IAAI,MAAM,gBAAgB,KAAK;AAAA,MACvC;AAAA;AAAA,IAGF,SAAS,MAAM,KAAK,QAAQ,OAAO,KAAK,OAAO,CAAC;AAAA;AAAA,EAGlD,MAAM,WAAW,OAAO,MAAc,UAAkB,MAAqB;AAAA,IAC3E,MAAM,OAAO,KAAK,MAAM,EAAE;AAAA,IAC1B,MAAM,UAAU,MAAM,OAAO;AAAA;AAAA,EAG/B,MAAM,aAAa,MAAY;AAAA,IAC7B,SAAS,SAAS,KAAK;AAAA;AAAA,EAGzB,MAAM,cAAc,MAAY;AAAA,IAC9B,SAAS,SAAS,MAAM;AAAA;AAAA,EAG1B,MAAM,WAAW,MAAY;AAAA,IAC3B,SAAS,SAAS,GAAG;AAAA;AAAA,EAGvB,MAAM,iBAAiB,MAAY;AAAA,IACjC,SAAS,SAAS,SAAS;AAAA;AAAA,EAG7B,MAAM,aAAa,CAAC,cAAsD;AAAA,IACxE,MAAM,SAAS;AAAA,MACb,IAAI,SAAS;AAAA,MACb,MAAM,SAAS;AAAA,MACf,MAAM,SAAS;AAAA,MACf,OAAO,SAAS;AAAA,IAClB;AAAA,IACA,SAAS,OAAO,UAAU;AAAA;AAAA,EAG5B,MAAM,aAAa,MAAY;AAAA,IAC7B,SAAS,SAAS,MAAM;AAAA;AAAA,EAG1B,MAAM,qBAAqB,CAAC,SAAgC;AAAA,IAC1D,OAAO,UAAU,CAAC,KAAK,qBAAqB,MAAM,KAAK,iBAAiB,CAAC;AAAA;AAAA,EAG3E,OAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAAA;;;ACtKK,IAAM,eAAe;AAAA,EAC1B,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,OAAO;AAAA,EAEP,UAAU;AAAA,EACV,YAAY;AAAA,EACZ,YAAY;AAAA,EACZ,aAAa;AACf;AAuBO,SAAS,eAAe,CAAC,UAAuB;AAAA,EACrD,IAAI,kBAAiC,EAAE,GAAG,GAAG,GAAG,EAAE;AAAA,EAClD,IAAI,iBAAiB,IAAI;AAAA,EAGzB,MAAM,qBAAqB,CACzB,MACA,GACA,GACA,SAAsB,aAAa,MACnC,YAA4B,CAAC,MAClB;AAAA,IAIX,IAAI,aAAqB;AAAA,IAGzB,IAAI,UAAU;AAAA,MAAO,cAAc;AAAA,IACnC,IAAI,UAAU;AAAA,MAAK,cAAc;AAAA,IACjC,IAAI,UAAU;AAAA,MAAM,cAAc;AAAA,IAElC,QAAQ;AAAA,WACD;AAAA,QACH,aAAa,KAAK;AAAA,QAClB,IAAI,UAAU;AAAA,UAAO,cAAc;AAAA,QACnC,IAAI,UAAU;AAAA,UAAK,cAAc;AAAA,QACjC,IAAI,UAAU;AAAA,UAAM,cAAc;AAAA,QAClC;AAAA,WACG;AAAA,QACH,cAAc,eAAe,OAAO,IAAI,MAAM,KAAK,cAAc,EAAE,KAAK,UAAU;AAAA,QAClF,IAAI,UAAU;AAAA,UAAO,cAAc;AAAA,QACnC,IAAI,UAAU;AAAA,UAAK,cAAc;AAAA,QACjC,IAAI,UAAU;AAAA,UAAM,cAAc;AAAA,QAClC;AAAA,WACG;AAAA,QAEH;AAAA;AAAA,IAIJ,MAAM,QAAQ,IAAI;AAAA,IAClB,MAAM,QAAQ,IAAI;AAAA,IAElB,IAAI,eAAe;AAAA,IACnB,IAAI,SAAS,QAAQ,SAAS,UAAU,SAAS,QAAQ;AAAA,MACvD,eAAe;AAAA,IACjB;AAAA,IAEA,OAAO,SAAS,cAAc,SAAS,QAAQ;AAAA;AAAA,EAGjD,MAAM,iBAAiB,OACrB,MACA,GACA,GACA,SAAsB,aAAa,MACnC,UAA6C,CAAC,MAC5B;AAAA,IAClB,QAAQ,YAAY,CAAC,GAAG,UAAU,MAAM;AAAA,IAExC,MAAM,gBAAgB,mBAAmB,MAAM,GAAG,GAAG,QAAQ,SAAS;AAAA,IACtE,SAAS,MAAM,KAAK,QAAQ,OAAO,KAAK,aAAa,CAAC;AAAA,IAEtD,kBAAkB,EAAE,GAAG,EAAE;AAAA,IAEzB,IAAI,SAAS,UAAU,SAAS,IAAI;AAAA,MAClC,eAAe,IAAI,MAAM;AAAA,IAC3B,EAAO,SAAI,SAAS,MAAM;AAAA,MACxB,eAAe,OAAO,MAAM;AAAA,IAC9B;AAAA,IAEA,IAAI,UAAU,GAAG;AAAA,MACf,MAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,OAAO,CAAC;AAAA,IAC7D;AAAA;AAAA,EAGF,MAAM,SAAS,OAAO,GAAW,GAAW,UAA6B,CAAC,MAAqB;AAAA,IAC7F,QAAQ,SAAS,aAAa,MAAM,UAAU,GAAG,YAAY,CAAC,MAAM;AAAA,IAEpE,IAAI,eAAe,OAAO,GAAG;AAAA,MAC3B,MAAM,eAAe,QAAQ,GAAG,GAAG,MAAM,KAAK,cAAc,EAAE,IAAI,EAAE,WAAW,QAAQ,CAAC;AAAA,IAC1F,EAAO;AAAA,MACL,MAAM,eAAe,QAAQ,GAAG,GAAG,QAAQ,EAAE,WAAW,QAAQ,CAAC;AAAA;AAAA,IAGnE,kBAAkB,EAAE,GAAG,EAAE;AAAA;AAAA,EAG3B,MAAM,QAAQ,OACZ,GACA,GACA,SAAsB,aAAa,MACnC,UAA6B,CAAC,MACZ;AAAA,IAClB,QAAQ,UAAU,IAAI,YAAY,CAAC,MAAM;AAAA,IAEzC,MAAM,eAAe,QAAQ,GAAG,GAAG,QAAQ,EAAE,WAAW,QAAQ,CAAC;AAAA,IACjE,MAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,OAAO,CAAC;AAAA,IAC3D,MAAM,eAAe,MAAM,GAAG,GAAG,QAAQ,EAAE,WAAW,QAAQ,CAAC;AAAA;AAAA,EAGjE,MAAM,cAAc,OAClB,GACA,GACA,SAAsB,aAAa,MACnC,UAA6B,CAAC,MACZ;AAAA,IAClB,QAAQ,UAAU,IAAI,YAAY,CAAC,MAAM;AAAA,IAEzC,MAAM,MAAM,GAAG,GAAG,QAAQ,EAAE,WAAW,QAAQ,CAAC;AAAA,IAChD,MAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,OAAO,CAAC;AAAA,IAC3D,MAAM,MAAM,GAAG,GAAG,QAAQ,EAAE,WAAW,QAAQ,CAAC;AAAA;AAAA,EAGlD,MAAM,YAAY,OAChB,GACA,GACA,SAAsB,aAAa,MACnC,UAA6B,CAAC,MACZ;AAAA,IAClB,QAAQ,YAAY,CAAC,GAAG,UAAU,MAAM;AAAA,IACxC,MAAM,eAAe,QAAQ,GAAG,GAAG,QAAQ,EAAE,WAAW,QAAQ,CAAC;AAAA;AAAA,EAGnE,MAAM,UAAU,OACd,GACA,GACA,SAAsB,aAAa,MACnC,UAA6B,CAAC,MACZ;AAAA,IAClB,QAAQ,YAAY,CAAC,GAAG,UAAU,MAAM;AAAA,IACxC,MAAM,eAAe,MAAM,GAAG,GAAG,QAAQ,EAAE,WAAW,QAAQ,CAAC;AAAA;AAAA,EAGjE,MAAM,OAAO,OACX,QACA,QACA,MACA,MACA,SAAsB,aAAa,MACnC,UAA6B,CAAC,MACZ;AAAA,IAClB,QAAQ,UAAU,IAAI,YAAY,CAAC,MAAM;AAAA,IAEzC,MAAM,UAAU,QAAQ,QAAQ,QAAQ,EAAE,UAAU,CAAC;AAAA,IAErD,MAAM,QAAQ;AAAA,IACd,MAAM,MAAM,OAAO,UAAU;AAAA,IAC7B,MAAM,MAAM,OAAO,UAAU;AAAA,IAE7B,SAAS,IAAI,EAAG,KAAK,OAAO,KAAK;AAAA,MAC/B,MAAM,WAAW,KAAK,MAAM,SAAS,KAAK,CAAC;AAAA,MAC3C,MAAM,WAAW,KAAK,MAAM,SAAS,KAAK,CAAC;AAAA,MAC3C,MAAM,eAAe,QAAQ,UAAU,UAAU,QAAQ,EAAE,WAAW,QAAQ,CAAC;AAAA,IACjF;AAAA,IAEA,MAAM,QAAQ,MAAM,MAAM,QAAQ,EAAE,UAAU,CAAC;AAAA;AAAA,EAGjD,MAAM,SAAS,OACb,GACA,GACA,WACA,UAA6B,CAAC,MACZ;AAAA,IAClB,QAAQ,YAAY,CAAC,GAAG,UAAU,MAAM;AAAA,IAExC,IAAI;AAAA,IACJ,QAAQ;AAAA,WACD;AAAA,QACH,SAAS,aAAa;AAAA,QACtB;AAAA,WACG;AAAA,QACH,SAAS,aAAa;AAAA,QACtB;AAAA,WACG;AAAA,QACH,SAAS,aAAa;AAAA,QACtB;AAAA,WACG;AAAA,QACH,SAAS,aAAa;AAAA,QACtB;AAAA;AAAA,IAGJ,MAAM,eAAe,UAAU,GAAG,GAAG,QAAQ,EAAE,WAAW,QAAQ,CAAC;AAAA;AAAA,EAGrE,MAAM,qBAAqB,MAAqB;AAAA,IAC9C,OAAO,KAAK,gBAAgB;AAAA;AAAA,EAG9B,MAAM,oBAAoB,MAAqB;AAAA,IAC7C,OAAO,MAAM,KAAK,cAAc;AAAA;AAAA,EAGlC,OAAO;AAAA,IAEL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IAGA;AAAA,IACA;AAAA,IAGA;AAAA,EACF;AAAA;;;ACxOF,IAAM,UAAU,IAAI;AAEpB,eAAsB,kBAAkB,CAAC,SAOtC;AAAA,EACD,QAAQ,IAAI,mBAAmB;AAAA,EAC/B,MAAM,WAAW,MAAM,kBAAkB;AAAA,OACpC;AAAA,IACH,oBAAoB;AAAA,IACpB,YAAY;AAAA,EACd,CAAC;AAAA,EAED,SAAS,0BAA0B;AAAA,EAEnC,MAAM,YAAY,eAAe,QAAQ;AAAA,EACzC,MAAM,YAAY,gBAAgB,QAAQ;AAAA,EAE1C,MAAM,aAAa,YAAY;AAAA,IAE7B,MAAM,SAAS,KAAK;AAAA;AAAA,EAGtB,OAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,kBAAkB,MAAM;AAAA,MACtB,MAAM,gBAAgB,SAAS;AAAA,MAC/B,MAAM,aAAa,cAAc,iBAAiB,IAAI;AAAA,MACtD,OAAO,QAAQ,OAAO,UAAU;AAAA;AAAA,IAElC,QAAQ,CAAC,OAAe,WAAmB;AAAA,MAEzC,SAAS,cAAc,OAAO,MAAM;AAAA;AAAA,EAExC;AAAA;AAGF,eAAe,iBAAiB,CAAC,QAA6B;AAAA,EAC5D,MAAM,QAAQ,OAAO,SAAS,QAAQ;AAAA,EACtC,MAAM,SAAS,OAAO,UAAU,QAAQ;AAAA,EAExC,MAAM,QAAQ,OAAO,SAAS,OAAO,WAAW;AAAA,EAChD,MAAM,SAAS,OAAO,UAAU,OAAO,QAAQ;AAAA,EAC/C,MAAM,eACJ,OAAO,4BAA4B,OAAO,2BAA2B,IAAI,OAAO,2BAA2B;AAAA,EAE7G,MAAM,SAAS,iBAAiB;AAAA,EAChC,MAAM,cAAc,OAAO,eAAe,OAAO,cAAc,EAAE,SAAS,KAAK,CAAC;AAAA,EAChF,IAAI,CAAC,aAAa;AAAA,IAChB,MAAM,IAAI,MAAM,gCAAgC;AAAA,EAClD;AAAA,EACA,IAAI,OAAO,cAAc,WAAW;AAAA,IAClC,OAAO,YAAY;AAAA,EACrB;AAAA,EAEA,IAAI,QAAQ,aAAa,SAAS;AAAA,IAChC,OAAO,YAAY;AAAA,EACrB;AAAA,EACA,OAAO,aAAa,aAAa,OAAO,SAAS;AAAA,EAEjD,MAAM,WAAW,IAAI,YAAY,QAAQ,aAAa,OAAO,QAAQ,OAAO,QAAQ,MAAM;AAAA,EAK1F,OAAO;AAAA;",
  "debugId": "DDD6AB1840C0574664756E2164756E21",
  "names": []
}