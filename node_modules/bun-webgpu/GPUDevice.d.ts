import { type Pointer } from "bun:ffi";
import { type FFISymbols } from "./ffi";
import type { InstanceTicker } from "./GPU";
import { EventEmitter } from "events";
type EventListenerOptions = any;
export type DeviceErrorCallback = (this: GPUDevice, ev: GPUUncapturedErrorEvent) => any;
export declare class DeviceTicker {
    readonly devicePtr: Pointer;
    private lib;
    private _waiting;
    private _ticking;
    constructor(devicePtr: Pointer, lib: FFISymbols);
    register(): void;
    unregister(): void;
    hasWaiting(): boolean;
    private scheduleTick;
}
export declare class GPUDeviceImpl extends EventEmitter implements GPUDevice {
    readonly devicePtr: Pointer;
    private lib;
    private instanceTicker;
    readonly ptr: Pointer;
    readonly queuePtr: Pointer;
    private _queue;
    private _userUncapturedErrorCallback;
    private _ticker;
    private _lost;
    private _lostPromiseResolve;
    private _features;
    private _limits;
    private _info;
    private _destroyed;
    private _errorScopePopId;
    private _popErrorScopeCallback;
    private _popErrorScopePromises;
    private _createComputePipelineAsyncCallback;
    private _createComputePipelineAsyncPromises;
    private _createRenderPipelineAsyncCallback;
    private _createRenderPipelineAsyncPromises;
    private _buffers;
    __brand: "GPUDevice";
    label: string;
    constructor(devicePtr: Pointer, lib: FFISymbols, instanceTicker: InstanceTicker);
    tick(): undefined;
    addEventListener<K extends keyof __GPUDeviceEventMap>(type: K, listener: (this: GPUDevice, ev: __GPUDeviceEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
    removeEventListener<K extends keyof __GPUDeviceEventMap>(type: K, listener: (this: GPUDevice, ev: __GPUDeviceEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
    handleUncapturedError(event: GPUUncapturedErrorEvent): void;
    handleDeviceLost(reason: GPUDeviceLostReason, message: string, override?: boolean): void;
    dispatchEvent(event: Event): boolean;
    pushErrorScope(filter: GPUErrorFilter): undefined;
    popErrorScope(): Promise<GPUError | null>;
    injectError(type: 'validation' | 'out-of-memory' | 'internal', message: string): undefined;
    set onuncapturederror(listener: DeviceErrorCallback | null);
    get lost(): Promise<GPUDeviceLostInfo>;
    get features(): GPUSupportedFeatures;
    get limits(): GPUSupportedLimits;
    get adapterInfo(): GPUAdapterInfo;
    get queue(): GPUQueue;
    destroy(): undefined;
    createBuffer(descriptor: GPUBufferDescriptor): GPUBuffer;
    createTexture(descriptor: GPUTextureDescriptor): GPUTexture;
    createSampler(descriptor?: GPUSamplerDescriptor): GPUSampler;
    importExternalTexture(descriptor: GPUExternalTextureDescriptor): GPUExternalTexture;
    createBindGroupLayout(descriptor: GPUBindGroupLayoutDescriptor): GPUBindGroupLayout;
    createPipelineLayout(descriptor: GPUPipelineLayoutDescriptor): GPUPipelineLayout;
    createShaderModule(descriptor: GPUShaderModuleDescriptor): GPUShaderModule;
    createBindGroup(descriptor: GPUBindGroupDescriptor): GPUBindGroup;
    _prepareComputePipelineDescriptor(descriptor: GPUComputePipelineDescriptor): ArrayBuffer;
    createComputePipeline(descriptor: GPUComputePipelineDescriptor): GPUComputePipeline;
    _prepareRenderPipelineDescriptor(descriptor: GPURenderPipelineDescriptor): ArrayBuffer;
    createRenderPipeline(descriptor: GPURenderPipelineDescriptor): GPURenderPipeline;
    createCommandEncoder(descriptor?: GPUCommandEncoderDescriptor): GPUCommandEncoder;
    createComputePipelineAsync(descriptor: GPUComputePipelineDescriptor): Promise<GPUComputePipeline>;
    createRenderPipelineAsync(descriptor: GPURenderPipelineDescriptor): Promise<GPURenderPipeline>;
    createRenderBundleEncoder(descriptor: GPURenderBundleEncoderDescriptor): GPURenderBundleEncoder;
    createQuerySet(descriptor: GPUQuerySetDescriptor): GPUQuerySet;
}
export {};
